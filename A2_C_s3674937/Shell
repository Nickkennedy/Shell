#!/bin/bash

# Name: Nicholas Kennedy
# StudentID: 3674937

# Prints out file creator
trap ctrl_c INT

function ctrl_c(){
	echo "THERE IS NO ESCAPING NOW! MUHAHAHAHHA"
}

header(){
	echo "====================================================="
	echo "Name: Nicholas Kennedy"
	echo "StudentID: 3674937"
	echo "======================================================"

}

showmenu(){
	clear
	unset WelcomeOptions
	header
	echo "1: System specifications (Assignment 2 part b)"
	echo "2: File Search"
	echo "3: basic profiler"
	echo "9: Exit"
	echo "======================================================"
	read -p "" WelcomeOptions
}

opt1menu(){
	clear
	unset Opt1Options
	header
	echo "1: Print the amount of free/occupied memory on the system"
	echo "2: Print the amount of free/occupied on the system"
	echo "3: Print connection infomation of all connected devices"
	echo "4: Print the amount of time the system has been running"
	echo "9: Back"
	echo "======================================================"
	read -p "" Opt1Options

	
	case $Opt1Options in
		1) 
		# Meminfo will print out data while using grip and a while card will search for memory items.
		# Grep filters out all unneeded rows and shows MemFree and MemTotal.
		awk '$2=="kB"{$2=$2/1024;$3="MB"} 1' /proc/meminfo |grep -E "MemFree|MemTotal"	
		opt1Secondmenu;;
	
		2) 
		# Print Meminfo and use awk to convert kB to MB. 
		# Grep filters out all unneeded rows and shows MemFree and MemTotal.
		awk '$3=="kB"{$2=$2/1024;$3="MB"} 1' /proc/meminfo |grep -E "MemAvailable|MemFree"
		opt1Secondmenu;;
		3)
		# Print network details.
		arp | awk '{ print "Current connected IP Address: " $1" and MAC Address: "$3 }'
		opt1Secondmenu;;
		4)
		# Use uptime and filter by awk to show hours up.
		uptime | awk '{print "The System has been up for "$3" hours"}'
		opt1Secondmenu;;

		9)
		showmenu;;

		*) 	
		# If the user does not enter in command, print out menu.
		echo "Invalid input. Try again."
		opt1Secondmenu;;
	esac

}

debug(){
	echo "~~~~~~~~~~~~~~~~~~~~~~~Debug~~~~~~~~~~~~~~~~~~~~~~~~~~"
	echo "Directory: $directory"
	echo "Filename: $filename"
	echo "Filetype: $filetype"
	echo "Filedepth: $filedepth"
	echo "Fileaction: $fileaction"
	find $directory -maxdepth $filedepth -name $filename -type $filetype
	#find -maxdepth $filedepth, -path $directory, -name $filename, -type $filetype, -exec $fileaction
	echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"

}

Searchforfile(){
	#Get user input
	clear
	header
	echo "Before we start the search, we just need to know some infomation."
	read -p "Where should we begin the search? " directory
	testdirectory
	read -p "what name are you looking for? " filename
	read -p "What is the file type? (f for file and d for director)" filetype
	testfiletype
	read -p "What is the maximum depth we can search? " filedepth
	testfiledepth
	read -p "What actions should we take? " fileaction	
	findresults
	echo "======================================================"
	read -p "Press any key to continue: " $return
}

findresults(){
	testfindresult

	# Counts results and determines if there are to many or none at all.
	if (($lines > 1))
	then
		echo "There are to many files! You will have to narrow down your results"
		find $directory -maxdepth $filedepth -name $filename -type $filetype
	elif (($lines < 1))
	then
		echo "No results sorry!"
	else
		debug
	fi
}

testfiledepth(){
	# Checks that the user enters a minumum of 1 else changes depth to 1.
	if (( $filedepth < 1 ))
	then
		echo "Cant search less then 1. Setting file depth to $filedepth deep"
		filedepth=1
	fi
}

testfiletype(){
	# Checks the file type is valid.
	case $filetype in 
		f) ;;
		d) ;;
		*)
		echo "Invalid file type. Setting to file type to f"
		filetype=f;;
	esac
}

testdirectory(){
	# Checks to see if the directory isnt empty
	if test -z "$directory"
	then
		echo "No directory set. Defaulting to your current directory"
		directory=$PWD
		echo $directory
	fi
	# Adds missing forward slash if missing.
	if [[ $directory != /* ]]
	then
		missing="/"
		temp=$missing$directory
		directory=$temp
	fi
}

testfindresult(){
	lines=$(find $directory -maxdepth $filedepth -name $filename -type $filetype| wc -l)

	echo "We found $lines matchs"
}


opt1Secondmenu(){
	clear
	header
	# getopts allows the user to pass in an argument under s and have the program react a specific way.
	# while the user can enter in arguments, these are caputed in the wild card *.

   	 # Print CPU Cored
	lscpu | grep "^CPU(s)" | awk '{print "The number of CPU cores on the system: "$2}'

	# Print current process prioirty
	ps -e -o uid,pid,comm,ni | grep $BASHPID | awk '{ print "The current process nice number is: " $4}'

	# Print the number of running process
	ps -eo user=|sort|uniq -c |awk '{ print "The total number of processings running under " $2 ": " $1}' | grep "$USER"

	# number of open files descriptors owned by current user
	lsof | grep "$USER" | wc -l | awk '{print "The number of open files descriptors owned by the currenr user: "$1}'

	# The maximum default number of files descriptors that can be opened by a process
	ulimit -n |awk '{print "The maximum default number of files that can be opened by a process: "$1}'
	echo "======================================================"
	read -p "Press any key to continue: " $return
	opt1menu
}

while true
do
showmenu

case $WelcomeOptions in 
	1) echo "one"
		opt1menu;;
	2) echo "Two" 
		Searchforfile;;
	3) echo "Three";;
	9) echo "Thanks for stopping by"
		exit;;
esac

done
